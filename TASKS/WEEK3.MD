# ðŸ“… Week 3 â€” End-to-End Encryption (Core Feature)

## ðŸŽ¯ Objective
Implement a **basic but correct End-to-End Encryption (E2EE)** system for the chat application such that:

- Messages are encrypted **on the client before sending**
- Messages are decrypted **only on the receiving client**
- The server **never has access to plaintext**
- Encryption works correctly for:
  - realtime messages
  - offline messages
  - page reloads
  - navigation between screens

This is **not WhatsApp-level E2EE**, but a **clean, interview-ready implementation** that demonstrates solid cryptography and system design fundamentals.

---

## ðŸ” Cryptography Stack Used

| Purpose | Algorithm |
|------|---------|
| User identity | RSA-OAEP |
| Message encryption | AES-256-GCM |
| Key exchange | RSA (public key crypto) |
| Integrity | AES-GCM authentication |

---

## ðŸ§  High-Level Design

- Each user owns a **long-term RSA key pair**
  - Public key â†’ stored on server
  - Private key â†’ stays on client
- Each conversation uses a **single AES session key**
- The AES key is:
  - generated once
  - encrypted separately using **each userâ€™s RSA public key**
  - stored on the server **only in encrypted form**
- Messages contain only:
  - ciphertext
  - IV
- **Encryption keys are never sent with messages**

---

## ðŸ—“ï¸ Day-wise Breakdown

---

### âœ… Day 1 â€” E2EE Architecture & Mental Model

- Understood why **hybrid encryption (RSA + AES)** is required
- Defined clear responsibilities:
  - RSA â†’ key exchange
  - AES â†’ message encryption
- Established the core rule:
  > If plaintext reaches the server, it is NOT end-to-end encrypted.

---

### âœ… Day 2 â€” RSA Key Pair Generation (Client-Side)

- Generated RSA key pairs using Web Crypto API
- Stored:
  - public key â†’ server
  - private key â†’ client only
- Learned why:
  - `CryptoKey` objects are non-serializable
  - `exportKey()` / `importKey()` are mandatory
- Ensured keys are generated **once per user**, not per login

---

### âœ… Day 3 â€” AES Encryption for Messages

- Implemented AES-256-GCM encryption
- Generated:
  - random IV per message
- Ensured:
  - encryption happens before sending
  - decryption happens after receiving
- Understood:
  - why IV must be unique
  - why IV is sent along with ciphertext

---

### âœ… Day 4 â€” AES Key Exchange (Major Challenges)

#### âŒ Problems Faced

1. **AES key sent with every message**
   - Broke E2EE design
   - Increased attack surface

2. **AES key regenerated multiple times**
   - Caused `OperationError` during decryption
   - Old messages became undecryptable

3. **Offline messages displayed encrypted text**
   - Receiver did not have AES key yet

---

#### âœ… Solution Implemented

- Separated **key exchange** from **message sending**
- Introduced a dedicated `/exchange` API
- AES key exchanged **once per conversation**
- Server stores **only RSA-encrypted AES keys**

---

### âœ… Day 5 â€” Directional Key Storage Bug (Critical Insight)

#### âŒ Problem

AES key was stored directionally as:


When the sender reopened the chat:
- reversed lookup failed
- app assumed no key existed
- new AES key was generated
- decryption failed for old messages

This caused:
- unnecessary updates
- key regeneration
- `OperationError`

---

#### âœ… Final Correct Solution

> **A conversation is symmetric, but encryption storage must be per-user.**

Implemented **two directional key records**:


This completely eliminated:
- reversed-query bugs
- accidental key regeneration
- decryption failures

---

### âœ… Day 6 â€” Navigation & State Loss Bug

#### âŒ Problem

- AES keys stored only in memory (`useRef`)
- Navigating away from chat page:
- cleared AES keys
- reopening chat regenerated new keys
- old messages failed to decrypt

---

#### âœ… Solution

- Implemented **AES key caching**
- Flow:
1. Check in-memory cache
2. Check localStorage cache
3. Fetch encrypted AES key from server
4. Decrypt using RSA private key
- Server remains **source of truth**
- localStorage acts as **temporary cache**, not authority

---

### âœ… Day 7 â€” Stabilization & Hardening

- Ensured:
- AES key generated **only once**
- RSA exchange happens **only once**
- Messages never carry keys
- Added:
- idempotent DB writes using `findOneAndUpdate`
- compound unique index on `(senderId, receiverId)`
- Verified:
- realtime messaging works
- offline messages decrypt correctly
- navigation does not break encryption

---

## ðŸ”’ Final Message Flow

1. User opens chat
2. Client ensures AES key exists:
 - restore from cache
 - or fetch encrypted AES key
 - or generate & exchange once
3. Message send:
 - encrypt with AES
 - send ciphertext + IV
4. Message receive:
 - decrypt with AES
5. Server:
 - never sees plaintext
 - never sees raw AES keys

---

## ðŸ§ª Issues Faced & Lessons Learned

| Issue | Lesson |
|----|----|
AES key in message payload | Keys must be exchanged, not transported |
Directional DB queries | Conversations are symmetric |
Key regeneration on reload | Crypto state must persist |
AES-GCM OperationError | Always caused by key mismatch |
Using memory only | Navigation destroys crypto state |

---

## ðŸ—£ï¸ Interview-Ready Summary

> I implemented a basic end-to-end encryption system using RSA for secure key exchange and AES-GCM for message encryption. Each conversation uses a single AES session key, which is encrypted separately for each user using their public RSA keys and stored encrypted on the server. Messages are encrypted on the client before sending and decrypted only on the receiving client, ensuring the server never has access to plaintext.

---

## âœ… Week 3 Status

- âœ” Real E2EE implemented
- âœ” RSA + AES hybrid encryption
- âœ” Offline & realtime support
- âœ” Navigation-safe
- âœ” Interview-defensible
- âœ” No crypto theater
